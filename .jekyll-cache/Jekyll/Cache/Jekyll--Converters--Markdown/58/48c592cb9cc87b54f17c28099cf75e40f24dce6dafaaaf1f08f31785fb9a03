I"÷9<p>Thread Control Block  TCB</p>

<p>https://docs.oracle.com/cd/E23824_01/html/819-0690/gentextid-22428.html#scrolltoc</p>

<h2 id="chapter-2-link-editor">Chapter 2 Link Editor</h2>
<h3 id="symbol-processing">Symbol Processing</h3>
<blockquote>
  <p>During input file processing, local symbols are copied from any input relocatable object files to the output object being built, <strong>without examination.</strong></p>
</blockquote>

<blockquote>
  <p>The global symbols from all input relocatable objects, and the global symbols from any external dependencies, are analyzed and combined in a process known as <strong>symbol resolution</strong>. The link-editor <strong>places  each symbol in an internal symbol table</strong> in the order that the symbols are encountered. If a symbol with the same name was contributed by an earlier object, and already exists in the symbol table, the symbol resolution process <strong>determines which</strong> of the two symbols to keep. As a side effect of this process, the link-editor determines how to establish references to external object dependencies.</p>
</blockquote>

<h4 id="symbol-resolution">Symbol Resolution</h4>
<blockquote>
  <p>The most common simple resolutions involve binding symbol references from one object to symbol definitions within another object. This binding can occur between two relocatable objects, or between a relocatable object and the first definition found in a shared object dependency.</p>
</blockquote>

<p>three basic symbol types</p>

<ol>
  <li>
    <p><strong>Undefined</strong> â€“ Symbols that have been referenced in a file but have not been assigned a storage address.</p>
  </li>
  <li>
    <p><strong>Tentative</strong> â€“ Symbols that have been created within a file but have not yet been sized, or allocated in storage. These symbols appear as uninitialized C symbols, or FORTRAN COMMON blocks within the file.</p>
  </li>
  <li>
    <p><strong>Defined</strong> â€“ Symbols that have been created, and assigned storage addresses and space within the file.</p>
  </li>
</ol>

<blockquote>
  <p>In its simplest form, symbol resolution involves the use of a <strong>precedence</strong> relationship. This relationship has <strong>defined</strong> symbols dominate <strong>tentative</strong> symbols, which in turn dominate <strong>undefined</strong> symbols</p>
</blockquote>

<h2 id="runtime-linker">Runtime Linker</h2>

<blockquote>
  <p>As part of the initialization and execution of an executable, an <strong>interpreter</strong> is called to complete the binding of the application to its dependencies. In the Oracle Solaris OS, this interpreter is referred to as the <strong>runtime linker</strong>.
During the link-editing of an executable, <strong>a special .interp section</strong>, together with an associated program header, are created. This section contains a path name specifying the programâ€™s interpreter. The default name supplied by the link-editor is the name of the runtime linker: /usr/lib/ld.so.1 for a 32-bit executable and /usr/lib/64/ld.so.1 for a 64-bit executable.
During the process of <strong>executing a dynamic object</strong>, the kernel loads the file and reads the program header information. See â€œProgram Headerâ€ on page 435. From this information, <strong>the kernel locates the name of the required interpreter. The kernel loads, and transfers control to this interpreter, passing sufficient information to enable the interpreter to continue executing the
application.</strong></p>
</blockquote>

<p>runtime linkerçš„åŠŸèƒ½</p>

<p>The runtime linker performs the following actions.</p>
<ol>
  <li>Analyzes the executableâ€™s dynamic information section (.dynamic) and determines what
dependencies are required.</li>
  <li>Locates and loads these dependencies, analyzing their dynamic information sections to
determine if any additional dependencies are required.</li>
  <li>Performs any necessary relocations to bind these objects in preparation for process
execution.</li>
  <li>Calls any initialization functions provided by the dependencies.</li>
  <li>Passes control to the application.</li>
  <li>Can be called upon during the applicationâ€™s execution, to perform any delayed function binding.</li>
  <li>Can be called upon by the application to acquire additional objects with dlopen(3C), and bind to symbols within these objects with dlsym(3C).</li>
</ol>

<p>runtime linkeræŸ¥æ‰¾è·¯å¾„ï¼š</p>
<ol>
  <li>é¦–å…ˆæŸ¥æ‰¾çš„æ˜¯ LD_LIBRARY_PATHè¿™ä¸ªç¯å¢ƒå˜é‡æŒ‡å®šçš„ç›®å½•ä¸‹çš„so</li>
  <li>å¦‚æœæ­¥éª¤1ä¸­æ²¡æœ‰æœç´¢åˆ°ï¼Œé‚£åˆ™æœç´¢runpathç›®å½•ä¸‹çš„soã€‚link-edité˜¶æ®µå†™å…¥objectä¸­.dynamicæ®µä¸­çš„æŸä¸ªentryï¼Œè¿™ä¸ªentryçš„tagæ˜¯RUNPATHï¼ŒæŒ‡å®šäº†æœç´¢è·¯å¾„</li>
  <li>å¦‚æœæ­¥éª¤2ä¸­ä¹Ÿæ²¡æœ‰æœç´¢åˆ°ï¼Œé‚£ä¹ˆå°±æœç´¢é»˜è®¤è·¯å¾„ï¼Œ32bitç³»ç»Ÿé»˜è®¤æœç´¢/lib and /usr/lib, 64bitç³»ç»Ÿé»˜è®¤æœç´¢/lib/64 and /usr/lib/64è·¯å¾„</li>
</ol>

<p>the use of LD_LIBRARY_PATH is strongly discouraged in production software</p>

<h3 id="relocation-processing">Relocation Processing</h3>

<blockquote>
  <p>After the runtime linker has loaded all the dependencies required by an application, the linker processes each object and performs all necessary relocations.</p>
</blockquote>

<blockquote>
  <p>During the link-editing of an object, any relocation information supplied with the input
relocatable objects is applied to the output file. However, when creating a dynamic object,
many of the relocations <strong>cannot be completed</strong> at link-edit time. These relocations require logical
addresses that are known only when the objects are loaded into memory. In these cases, the
<strong>link-editor</strong> generates <strong>new relocation records</strong> as part of the output file image. The <strong>runtime linker</strong>
must then <strong>process</strong> these new relocation records.</p>
</blockquote>

<p>Two basic types of relocation exist.</p>
<ol>
  <li>Non-symbolic relocations</li>
  <li>Symbolic relocations</li>
</ol>

<p>With this model, the first occurrence of the required symbol satisfies the search. Therefore, if more than one instance of the same symbol exists, the first instance interposes on all others.</p>

<h3 id="initialization-and-termination-routines">Initialization and Termination Routines</h3>

<p>Dynamic objects can supply code that provides for runtime initialization and termination
processing. The initialization code of a dynamic object is executed once each time the dynamic
object is loaded in a process. The termination code of a dynamic object is executed once each
time the dynamic object is unloaded from a process or at process termination.</p>

<p>Before transferring control to an application, the runtime linker processes any initialization
sections found in the application and any loaded dependencies. If new dynamic objects are
loaded during process execution, their initialization sections are processed as part of loading the
object. The initialization sections .preinit_array, .init_array, and .init are created by the
link-editor when a dynamic object is built.</p>

<p>An executable can provide pre-initialization functions in a .preinit_array section. These
functions are executed after the runtime linker has built the process image and performed
relocations but before any other initialization functions. Pre-initialization functions are not
permitted in shared objects.
Note - Any .init section within the executable is called from the application by the process
startup mechanism supplied by the compiler driver. The .init section within the executable is
called last, after all dependency initialization sections are executed.</p>

<h2 id="shared-objects">Shared Objects</h2>
<blockquote>
  <p>Shared objects are one form of output created by the link-editor and are generated by specifying
the -G option.
A shared object is an indivisible unit that is generated from one or more relocatable objects.
Shared objects can be bound with executables to form a runnable process. As their name
implies, shared objects can be shared by more than one application</p>
</blockquote>

<blockquote>
  <p>Any input shared objects become dependencies of this output file. A small amount of
bookkeeping information is maintained within the output file to describe these dependencies.
The runtime linker interprets this information and completes the processing of these shared
objects as part of creating a runnable process.</p>
</blockquote>

<p>During the link-edit of a shared object, its runtime name can be recorded within the shared
object itself by using the -h option. In the following example, the shared objectâ€™s runtime name
libfoo.so.1, is recorded within the file itself. This identification is known as an soname.</p>

<h4 id="relocation-sections">Relocation Sections</h4>
<blockquote>
  <p><strong>Relocation is the process of connecting symbolic references with symbolic definitions</strong>. For
example, when a program calls a function, <strong>the associated call instruction must transfer control to the proper destination address at execution</strong>. Relocatable files must have information that
describes how to modify their section contents. This information allows dynamic object files to <strong>hold the right information</strong> for a processâ€™s program image. <strong>Relocation entries are these data</strong>.</p>
</blockquote>

<p>sys/elf.h</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> --><td class="rouge-code"><pre>typedef struct {
        Elf32_Addr      r_offset;
        Elf32_Word      r_info;
} Elf32_Rel;

typedef struct {
        Elf32_Addr      r_offset;
        Elf32_Word      r_info;
        Elf32_Sword     r_addend;
} Elf32_Rela;

typedef struct {
        Elf64_Addr      r_offset;
        Elf64_Xword     r_info;
} Elf64_Rel;

typedef struct {
        Elf64_Addr      r_offset;
        Elf64_Xword     r_info;
        Elf64_Sxword    r_addend;
} Elf64_Rela;
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>r_offset</strong>
This member gives the location at which to apply the relocation action. Different object files have slightly different interpretations for this member.</p>

<p>For a relocatable file, the value indicates a section offset. The relocation section describes how to modify another section in the file. Relocation offsets designate a storage unit within the second section.
å°±æ˜¯è¯´ï¼Œè¿™ä¸ªoffsetæè¿°äº†å¦‚ä½•ä¿®æ”¹å¦ä¸€ä¸ªæ®µä¸­offsetå¤„çš„ä¸€å—å†…å­˜åŒºåŸŸã€‚</p>

<p>For a dynamic object, the value indicates the virtual address of the storage unit affected by the relocation. This information makes the relocation entries more useful for the runtime linker.
å¯¹äºåŠ¨æ€å¯¹è±¡æ¥è¯´ï¼Œè¿™ä¸ªå€¼æŒ‡ç¤ºäº†å—é‡å®šä½å½±å“çš„å­˜å‚¨å•å…ƒçš„è™šæ‹Ÿåœ°å€ï¼Œå¯¹runtime linkeræ¥è¯´ï¼Œè¯¥é‡å®šä½æ¡ç›®éå¸¸æœ‰ç”¨ã€‚</p>

<p>Although the interpretation of the member changes for different object files to allow efficient access by the relevant programs, the meanings of the relocation types stay the same.</p>

<h3 id="program-loading-and-dynamic-linking">Program Loading and Dynamic Linking</h3>

<p>Executables and shared objects <strong>statically represent</strong> application programs. To execute such programs, the system uses the objects to create <strong>dynamic program representations, or process images</strong>. A process image has segments that contain its text, data, stack, and so on.</p>

<h4 id="base-address">Base Address</h4>
<p>Dynamic objects have a base address, which is the lowest virtual address associated with the memory image of the programâ€™s object file. One use of the base address is to <strong>relocate</strong> the memory image of the program during dynamic linking.</p>

<p><strong>The base address of a dynamic object is calculated during execution from three values</strong>: the memory load address, the maximum page size, and the lowest virtual address of a programâ€™s loadable segment. The virtual addresses in the program headers might not represent the actual virtual addresses of the programâ€™s memory image.
åœ¨æ‰§è¡ŒæœŸé—´ï¼Œä¸€ä¸ªåŠ¨æ€å¯¹è±¡çš„åŸºå€æ˜¯æ ¹æ®è¿™ä¸‰ä¸ªå€¼è®¡ç®—å‡ºæ¥çš„*****</p>

<h4 id="segment-contents">Segment Contents</h4>
<p>An object file segment consists of one or more sections, though this fact is transparent to the program header. Whether the file segment holds one section or many sections, is also immaterial to program loading.</p>

<h3 id="program-loading">Program Loading</h3>

<p>As the system creates or augments a process image, the system <strong>logically</strong> copies a fileâ€™s segment to a virtual memory segment. When, and if, the system <strong>physically</strong> reads the file depends on the programâ€™s execution behavior, system load, and so forth.</p>

<p>A process does not require a physical page <strong>unless</strong> the process <strong>references</strong> the logical page during execution. Processes commonly leave many pages <strong>unreferenced</strong>. Therefore, delaying physical reads can improve system performance. To obtain this efficiency in practice, dynamic objects
must have segment images whose file offsets and virtual addresses are <strong>congruent</strong>, <strong>modulo</strong> the page size.</p>

<hr />

<ol>
  <li>Historically, weak symbols have been used to <strong>circumvent interposition</strong>, or test for optional functionality.</li>
  <li>Although this archive extraction can be
achieved by specifying multiple -u options to the link-edit, this example also shows how the <strong>eventual scope</strong> of a symbol can be reduced to local.</li>
</ol>

<p>These environment variables <strong>are well suited to</strong> debugging purposes, such as forcing an application to bind to a local dependency.</p>

<p>However, this compensation can undermine the advantages of a lazy loading.</p>

<p>Neither the link-editor nor the runtime linker interprets any file by virtue of its file name</p>

<p>Whether the file segment holds one section or many sections, is also
<strong>immaterial</strong> to program loading.</p>

<p>error: RPC failed; curl 56 GnuTLS recv error (-9): Error decoding the received TLS packet.</p>

<p>fatal: The remote end hung up unexpectedly. fatal: early EOF fatal: index-pack failed</p>

<p>ä¹±ç çš„è§£å†³æ–¹æ¡ˆ
alias tree=â€™tree â€“charset ASCIIâ€™</p>

<p>é©±åŠ¨å¤„ç†æ–¹å¼
http://blog.leanote.com/post/yangtianrui95@gmail.com/AOSP-%E5%BC%80%E5%8F%91%E5%B9%B6%E5%88%B7%E5%85%A5Pixel</p>

<p>tar zxvf qcom-walleye-qq3a.200705.002-b7555c81.tgz</p>

<p>tar   zxvf  google_devices-walleye-qq3a.200705.002-42602ba1.tgz</p>

<p>m -j8</p>

:ET