[ { "title": "通过例子查看编译器编译流程", "url": "/2020-12-06-simple-example.html", "categories": "", "tags": "art, default", "date": "2020-12-06 00:00:00 +0800", "snippet": "简介下面我们通过一个小例子来学习下编译器处理相关小知识package android.app;public class CompilerHelper { /**{@hide}*/ int zhenghanhan(int a, int b, int c){ if (a &amp;gt; b) { return a; } switch(a){ case 1: a += 1; break; case 2: ..." }, { "title": "加载libart.so步骤", "url": "/2020-09-07-libart-so.html", "categories": "", "tags": "art, default", "date": "2020-09-07 00:00:00 +0800", "snippet": "简介我们知道，java虚拟机一般都是以动态库的形式暴露给外界，供外部开发者来集成使用的。在art中，它的文件名叫做libart.soapp_process这个程序集成了libart.so，并以zygote的形式运行起来，作为后续所有的安卓应用进程的父进程我们看下上图中的1172行，这里jni_invocation.Init(NULL);里面会加载虚拟机所在的动态库libart.so，并从动态库中获取创建虚拟机所需的函数指针。我们进去看下，如下图：在图里的237行，handle_ = OpenLibrary(library);这里，拿到了动态库的句柄，然后通过handle_和dlsymbo..." }, { "title": "应用启动流程分析", "url": "/2020-09-10-app-start.html", "categories": "", "tags": "art, default", "date": "2020-09-07 00:00:00 +0800", "snippet": "ZygoteInit.main我们知道，虚拟机创建后，执行的第一个java代码是ZygoteInit的main方法，我们来看下这个方法内部的一些主要代码：...zygoteServer = new ZygoteServer(isPrimaryZygote);if (startSystemServer) { Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // {@code r == null} in the parent (zygote) process, and {@code r..." }, { "title": "Dex2Oat 编译选项列表", "url": "/2020-08-26-dex2oat_options.html", "categories": "", "tags": "art, default", "date": "2020-08-27 00:00:00 +0800", "snippet": "简介笔者在编译产物中直接执行out/soong/host/linux-x86/bin/dex2oatd，该命令会输出编译选项，如下：Output must be supplied with either --oat-file or --oat-fd Command: out/soong/host/linux-x86/bin/dex2oatd Usage: dex2oat [options]... -j&amp;lt;number&amp;gt;: specifies the number of threads used for compilation. Default..." }, { "title": "Dex2Oat基础", "url": "/2020-08-26-dex2oat_basics.html", "categories": "", "tags": "art, default", "date": "2020-08-26 00:00:00 +0800", "snippet": "简介在我们构建出来的out目录下，有一个叫做verbose.log.gz的文件，我们使用gzip -d verbose.log.gz可以得到一个文本文件verbose.log，它保存了在构建整个系统的时候，详细的构建流程。我们从这个log中截取构建boot.oat文件的构建命令[63549/63992]mkdir -p out/soong/walleye/dex_bootjars_unstripped/system/framework/arm &amp;amp;&amp;amp; rm -f out/soong/walleye/dex_bootjars_unstripped/system..." }, { "title": "ART中编译器相关基础知识记录", "url": "/2020-08-20-art_compiler_basics.html", "categories": "", "tags": "art, default", "date": "2020-08-20 00:00:00 +0800", "snippet": "基础数据结构简介vim art/compiler/optimizing/nodes.h +312// Control-flow graph of a method. Contains a list of basic blocks.class HGraph : public ArenaObject&amp;lt;kArenaAllocGraph&amp;gt; { public: HGraph(ArenaAllocator* allocator, ArenaStack* arena_stack, const DexFile&amp;amp; dex_fil..." }, { "title": "AOSP源码下载、编译与刷机", "url": "/2020-07-27-aosp_build.html", "categories": "", "tags": "art, default", "date": "2020-07-27 00:00:00 +0800", "snippet": "环境简介笔者的电脑是一款Win10笔记本电脑（内存16GB * 2），通过VMware® Workstation 15 Pro虚拟机虚拟出一个Ubuntu 20.04操作系统实例。详细的参数如下图：分配给这个虚拟机实例的资源配置如下：我给ubuntu实例分配了500+GB的磁盘，并分配了22GB的内存（因为编译AOSP很耗费内存），现在编译完了，笔者又把它手动调低到了图中的16-GB。编译AOSP的时候，除了分配22GB的内存外，笔者还在ubuntu实例中分配了一个32GB的swap空间，担心内存不够，发生交换。快速创建swap空间可以参考这篇文章。AOSP源码下载由于墙的原因，在国内无..." }, { "title": "Thread Local Storage", "url": "/posts/thread-local-storage/", "categories": "", "tags": "", "date": "2020-07-20 00:00:00 +0800", "snippet": "Thread Control Block TCBhttps://docs.oracle.com/cd/E23824_01/html/819-0690/gentextid-22428.html#scrolltocChapter 2 Link EditorSymbol Processing During input file processing, local symbols are copied from any input relocatable object files to the output object being built, without examination. ..." }, { "title": "JNI学习开动篇", "url": "/2020-07-16-jni_getting_started.html", "categories": "", "tags": "jni", "date": "2020-07-16 00:00:00 +0800", "snippet": "引言以Zygote启动来看涉及的JNI过程system/core/rootdir/init.zygote64.rcservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system onrestart write /sys/and..." }, { "title": "计算机专业好书推荐", "url": "/2019-12-30-computer-books.html", "categories": "", "tags": "general, default", "date": "2019-12-30 00:00:00 +0800", "snippet": "今天给大家推荐几本计算机专业相关的经典书籍，大部分是我在研究生期间看过的，少部分是工作后看的或者正在看的。工作这一年多来，最大的感受就是忙，留有的看书时间太少了，希望在即将到来的2020年能够多挤些时间读书，多读好书，不论专业书籍还是非专业书籍亦或者会议、期刊类学术文章，这个帖子也算是立贴为证，提醒自己吧综合 Computer Systems:A Programmer’s Perspective《深入理解计算机系统》豆瓣9.6的神书，我首推的一本书，非常棒 Structure and Interpretation of Computer Programs《计算机程..." }, { "title": "Dataflow Analysis中的Anticipable Expressions Analysis", "url": "/posts/anticipable-expressions-analysis/", "categories": "compiler", "tags": "theory", "date": "2019-10-14 00:00:00 +0800", "snippet": "本文介绍Dataflow Analysis中的Anticipable Expressions Analysis定义首先，先给出两个关于Anticipable Expressions的定义12An expression e is considered anticipable, or very busy, on exit from block b if and only if (1) every path that leaves b evaluates and subsequently uses e, and (2) evaluating e at the endof b would pro..." }, { "title": "Dataflow Analysis中的Available Expressions Analysis", "url": "/posts/available-expression-analysis/", "categories": "compiler", "tags": "theory", "date": "2019-10-13 00:00:00 +0800", "snippet": "先看下Available Expressions提出的动机和定义available expressions is an analysis algorithm that determines for each point in the program the set of expressions that need not be recomputed. Those expressions are said to be available atsuch a point. To be available on a program point, the operands of the expre..." }, { "title": "Liveness Analysis", "url": "/posts/liveness-analysis/", "categories": "", "tags": "", "date": "2019-10-12 00:00:00 +0800", "snippet": "title: Dataflow Analysis中的Liveness Analysisauthor: zjhdate: 2019-10-12last_modified_at: 2021-02-17categories: [compiler]tags: [theory]—如果物品生产出来，最终却没有被使用，那么它就是没有价值的，因此这个物品也就没必要生产，原先生产这个物品过程中占用的资源也可以留作它用。举两个例子 亲戚来家里做客，然后爸妈准备下厨做饭，一口气做了18盘菜。饭毕，发现这18盘菜只有10盘菜被客人食用过，其他8盘菜原封未动，那如果早知道这8盘菜没人吃，那一开始不做就..." }, { "title": "RPO在数据流分析中的应用", "url": "/2019-10-11-rpo-in-graph.html", "categories": "", "tags": "compiler, llvm, default", "date": "2019-10-11 00:00:00 +0800", "snippet": "引言经常能在一些编译器书籍资料中看到Reverse Post-order(RPO)这个名词，特别是在数据流分析相关章节中。比如下面的这句 For a forward data-flow problem, such as Dom, the iterative algorithm should use an rpo computed on the cfg. For a backward data-flow problem, such as LiveOut, the algorithm should use an rpo computed on the reverse cfg.一般地，数据流..." }, { "title": "图相关知识回顾", "url": "/posts/graph-basics/", "categories": "compiler", "tags": "graph", "date": "2019-10-10 00:00:00 +0800", "snippet": "引言编译器中经常会涉及一些图相关的概念，本文借此粗略整理了一些图相关的概念，一是回顾回顾，二是方便日后查阅。KeyWordsGraph; Tree; Tree Edge; Back Edge; Forward Edge; Cross Edge; Cycle; DAG; Articulation Point (or Vertex); Connected Componet; Strongly-connected Component; Reverse Post-order; Topological sortContent图一般地，图分有向图（Directed Graph）和无向图（Undire..." }, { "title": "LLVM IR-增删改查简介", "url": "/2019-10-09-llvm_ir_crud.html", "categories": "", "tags": "compiler, llvm, default", "date": "2019-10-09 00:00:00 +0800", "snippet": "引言本文使用两种方式来对IR进行操作，一个是生成一个单独的可执行文件来对IR进行操作，一个是写一个Pass，生成一个动态库，然后通过给clang或者opt添加参数选项来调用这个动态库，从而达到操作IR的目的。以下代码在LLVM 10上测试通过。生成单独可执行文件来对IR进行操作 首先给一个C语言写的例子#include &amp;lt;stdio.h&amp;gt;int funb(int x, int y) { if (x &amp;gt; y) { return x - y; } return y -x;}int func(int x, int y, int z){ ..." }, { "title": "LLVM IR-重要数据结构简介", "url": "/2019-10-08-llvm_ir_key_data_structure_introduction.html", "categories": "", "tags": "compiler, llvm, default", "date": "2019-10-08 00:00:00 +0800", "snippet": "引言在LLVM IR简介一文中，我们提到LLVM IR有三种存在形式，在简介一文中介绍了存在在文件中的可读IR和二进制IR，本文将粗略介绍下IR在内存中的形态对应的数据结构。常见类的层次结构（Class Hierarchy） Value及常见子类我大致绘制了一些常见的Value的子类，每个Value类型的实例都是有Type的。关于Value官方文档有这样一段话： The Value class is the most important class in the LLVM Source base. It represents atyped value that may be used..." }, { "title": "LLVM IR 概览 - 续 - getelementptr", "url": "/2019-10-06-llvm_ir_overview_getelementptr.html", "categories": "", "tags": "compiler, llvm, default", "date": "2019-10-07 00:00:00 +0800", "snippet": "我们经常能够在LLVM IR中发现getelementptr，那么这条指令是何作用？通过一个例子一起来看一下例子1struct RT { char A; int B[10][20]; char C; }; struct ST { int X; double Y; struct RT Z; }; int *foo(struct ST *s) { return &amp;amp;s[1].Z.B[5][13]; }" }, { "title": "LLVM IR 概览", "url": "/2019-10-06-llvm_ir_overview.html", "categories": "", "tags": "compiler, llvm, default", "date": "2019-10-06 00:00:00 +0800", "snippet": "引言现代程序员写程序一般都是使用高级语言（例如C、C++、Objective-C）来进行书写的，每种高级语言都有其独特的语法，使用相同的算法和相似的数据结构实现同一个功能，不同的语言写出来的也是不一样的。对于编译器来说，如果能够屏蔽这些语法带来的差异，将程序转换成一种共通的语言来表示，那么就可以专心的针对这个共通的语言来研究如何对其优化，使得最后生成的程序能够更优（从时间、空间等方面）。相关的优化算法实现也因此具有通用性、可重用性。在LLVM中，这个共通的语言，就是LLVM IR。IR是Intermediate Representation的缩写，即中间描述或者中间表示。在LLVM中，C..." }, { "title": "LLVM源码下载与编译", "url": "/2019-10-05-llvm_src_download_and_compile.html", "categories": "", "tags": "getting_started, compiler, llvm, default", "date": "2019-10-05 00:00:00 +0800", "snippet": "环境简介笔者的环境是搭在VMware Workstation虚拟出的Ubuntu 20.04操作系统实例上的，VMware Workstation运行在搭载着Win10系统的笔记本上，笔记本硬件配置 CPU i7-8750H，内存16GB*2。LLVM源码下载LLVM的下载来源主要来自于这两个官方链接，一个是LLVM 稳定版本的下载1，即稳定的发布版本。一个是LLVM在github上的下载2，这个可以理解成最新的不断更新的开发版本。本文采用后者。将整个LLVM大项目下载下来（包含clang，llvm core，compiler-rt等等），整个过程比较耗时。笔者在计算机上手动新建了一个目..." }, { "title": "LLVM学习开动篇", "url": "/posts/llvm_getting_started/", "categories": "compiler", "tags": "getting_started", "date": "2019-10-04 00:00:00 +0800", "snippet": "引言编译器是一类有着悠久历史的计算机程序。该类程序的目标是将某种编程语言写出来的计算机代码翻译成另一种语言1。一般地，我们使用高级语言（例如C/C++、JAVA）将代码写出来，然后使用编译器将这些代码翻译成更接近目标机器可运行的低级语言（例如汇编、字节码）。现代编译器的工作流程一般被划分成三个阶段1:Workflow of Modern Compiler Workflow of Modern Compiler前端（Front end）：我们熟悉的词法分析（lexical analysis）、语法分析（syntax analysis）和语义分析（semantic analysis）都集中在..." } ]
